#include "imports/stdlib.fc";


;; storage#_ microusd_per_ton: uint32  // 2.3232 USD -> 2323200
;;     min_cr: uint16  // 1.5 -> 1500
;;     last_update: uint64
;;     vaults: (HashmapE 267 Vault)
;;     oracle_address: MsgAddressInt
;;     jetton_master_address: MsgAddressInt
;;     jetton_wallet_code: ^Cell
;;     = Storage;

const int op::update_price = 0x1;
const int op::borrow = 0x2;

(int, int, int, cell, slice, slice, cell) load_data() inline {
    slice ds = get_data().begin_parse();
    return (ds~load_uint(32),
            ds~load_uint(16),
            ds_load_uint(64),
            ds~load_dict(),
            ds~load_msg_addr(),
            ds~load_msg_addr(),
            ds~load_ref());
}

() save_data(int microusd_per_ton, int min_cr, int last_update, cell vaults, slice oracle_address, slice jetton_master_address, cell jetton_wallet_code) impure {
    set_data(begin_cell()
        .store_uint(microusd_per_ton, 32)
        .store_uint(min_cr, 16)
        .store_uint(last_update, 64)
        .store_dict(vaults)
        .store_msg_addr(oracle_address)
        .store_msg_addr(jetton_master_address)
        .store_ref(jetton_wallet_code)
        .end_cell());
}

() liquidate_collateral(int addr_int, slice vault_sliced) impure { }

cell filter_by_dcr(cell vaults, int min_dcr) impure inline {
    ;; Only for MVP.
    ;; Liquidation of more than 250 vaults is not supported.
    ;; Also can run out of gas.

    int prev_addr = 0;
    do {
        (prev_addr, slice vault, int s) = vaults.udict_get_next?(267, prev_addr);
        if (s) {
            int dcr = vault.load_uint(16);
            if (dcr <= min_dcr) {
                liquidate_collateral(prev_addr, vault);
                vaults~udict_delete?(267, prev_addr);
            }
        }
    } while (s);

    return vaults;
}

() update_price_from_oracle(slice in_msg_body, slice sender_address) {
    (int microusd_per_ton, int min_cr, int last_update, cell vaults, slice oracle_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();

    throw_unless(600, equal_slices?(sender_address, oracle_address));

    int query_id = in_msg_body~load_uint(64);
    int microusd_per_ton = in_msg_body~load_uint(64);

    int min_dcr = min_cr * 1000 / microusd_per_ton

    vaults~filter_by_dcr(min_dcr);

    last_update = now();

    save_data(microusd_per_ton, min_cr, last_update, vaults, oracle_address, jetton_master_address, jetton_wallet_code);

    return ();
}

() borrow(slice in_msg_body, slice sender_address) {
    (int microusd_per_ton, int min_cr, int last_update, cell vaults, slice oracle_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();
    int sender_address_int = sender_address.load_uint(267);

    (slice vault, int there?) = vaults.udict_get?(267, sender_address_int);
    int (dcr, collateral, debt) = there?
          ? (vault~load_uint(16), vault~load_coins(), vault~load_coins())
          : (0, 0, 0);
    int
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }

    slice sender_address = cs~load_msg_addr();

    int op = in_msg_body~load_uint(32);

    if (op == op::update_price) {
        return update_price_from_oracle(in_msg_body, sender_address);
    }

    if (op == op::borrow) {
        return borrow(in_msg_body, sender_address);
    }
}
